# -*- coding: utf-8 -*-

"""
parse_and_decomp_mcs.py

Parse and decompress MCSs found with aspefm

Collaboration with Jérémie Muller-Prokob: https://github.com/JoPkb/RBA_cutsets

Requires library tqdm
"""

import cobra
import pandas as pd
from itertools import combinations, combinations_with_replacement, permutations, chain, product
from tqdm import tqdm
import sys
import pickle
from argparse import ArgumentParser

def knock_out(model, lr):
    model = model.copy()
    for r in lr:
        lb = False
        r = r[:] # remove quotes and ending bracket
        if r.startswith('mcs_'):
            r = r[4:]
        if r.startswith('R_'):
            r = r[2:]
        if r.endswith('_rev'):
            r = r[:-4]
            lb = True
        gr = model.reactions.get_by_id(r)
        if lb:
            gr.lower_bound = 0
        else:
            gr.upper_bound = 0
    return model

def sol_after_ko(lr, model, obj="", check_reaction=None):
    try:
        model_c = knock_out(model, lr)
        #model_c.objective = obj
        opt = model_c.optimize()
        if check_reaction:
            print(f"Reaction {check_reaction} : flux = {model_c.reactions.get_by_id(check_reaction).flux}")
        return opt.objective_value if opt.status != 'infeasible' else 0.0
    except KeyError as e:
        #warnings.warn(str(e))
        #return 0.0
        print(f"reaction {str(e)} not found")
        return 0.0

def nm1_combinations(orig_lr, model, saves):
    all_lr = {}
    for lr in itertools.combinations(orig_lr, len(orig_lr)-1):
        fs = frozenset(lr)
        if fs not in saves:
            saves[fs] = sol_after_ko(lr, model)
        all_lr[fs] = saves[fs]
        if all_lr[fs] == 0.0:
            saves[frozenset(orig_lr)] = 0.0
            return 0.0, all_lr, fs
    orig = sol_after_ko(orig_lr, model)
    saves[frozenset(orig_lr)] = orig
    return orig, all_lr, None


def parse_output(path):
    with open(path) as output_mcs_buffer:
        output_mcs_data = output_mcs_buffer.readlines()

    cutset_list = []
    for line in output_mcs_data:
        if "cutset" in line:
            reacs = line.strip("\n").split("cutset(\"")[1:]
            cutset_list.append([rid.split("\")")[0] for rid in reacs])
    return cutset_list

def itertools_product(listofcutsets, model):
    i = 1
    good_cutsets = []
    for cutset_orID in tqdm(listofcutsets):
        good_cutsets_subs = []
        #print(f"Cutset : {cutset_orID}\n")
        cuts_combinations = list(product(*cutset_orID)) # decompression
        for comb in cuts_combinations:
            with model as m:
                retval = sol_after_ko(comb, m)
                # for reac in cs:
                #     m.reactions.get_by_id(reac.strip("_rev"))
                #opt = m.optimize()
            #print("<",opt.objective_value,">", cs )
            if retval < 1e-6:
                good_cutsets_subs.append(comb)
            else:
                print(f"{comb} is not a cutset.")

            if len(comb) > 1 :
                for nm1 in combinations(comb, len(comb)-1):
                    retval = sol_after_ko(nm1, m)
                    if retval < 1e-6:
                        print('[N-1]',"Objective value = ", retval,"For n-1 subset\
                           of cutset >>>", nm1, 'not MIN cutset')
        good_cutsets.append(good_cutsets_subs)
        i+=1
    return good_cutsets

if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument('cutsets_path', default=None, metavar='Clingo output', help='Clingo output file')
    parser.add_argument('model_path', metavar='SBML Path', help='SBML model file')
    parser.add_argument('reaction_subsets', default=None, metavar='Reaction subsets dict', help='Reaction subsets dict as generated by model compression')
    parser.add_argument('output_path', default=None, metavar='Output Pickle file', help='Store decompressed MCSs in Pickle')
    opts = parser.parse_args()
    cutsets_path = opts.cutsets_path # sys.argv[2]
    model_path = opts.model_path # sys.argv[1]
    reaction_subsets = opts.reaction_subsets # sys.argv[3]
    output_path = opts.output_path # sys.argv[4]
    model = cobra.io.read_sbml_model(model_path)
    cutsets_list = parse_output(cutsets_path)
    with open(reaction_subsets, 'r') as buffer_subsets:
        reaction_subsets_dict = eval(buffer_subsets.read())
    listofcutsets_original_id = []
    for reac_list in cutsets_list:
        #Pour chaque cutset:

        cutset_original_IDs = []
        #print(f"\n\nFor cutset {reac_list}:\n\n")
        for comp_reac_id in reac_list:
            reac_subset = reaction_subsets_dict[comp_reac_id[4:]]["reacs"]
            cutset_original_IDs.append(reac_subset)
        listofcutsets_original_id.append(cutset_original_IDs)
    
    good_cutsets = itertools_product(listofcutsets_original_id, model)
    with open(output_path, "wb") as out:
        pickle.dump(good_cutsets,out)
